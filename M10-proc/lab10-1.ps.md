## LAB10-1. Процессы в Linux 

#### Управление заданиями
1. Откройте **shell** как **student** и введите следующие команды:
```bash
sleep 3600 &
dd if=/dev/zero of=/dev/null &
sleep 7200
```

2. Поскольку вы запустили последнюю команду без `&` после команды, вам нужно подождать **2** часа, прежде чем вы снова получите управление оболочкой. Нажмите `Ctrl-Z`, чтобы остановить команду.

3. Введите `jobs`. Вы увидите три задания, которые только что начали. Первые два из них находятся в состоянии **"Запущен"**, а последнее задание в настоящее время находится в состоянии **"Остановлено"**.
```console
jobs
[1]   Запущен          sleep 3600 &
[2]-  Запущен          dd if=/dev/zero of=/dev/null &
[3]+  Остановлен    sleep 7200
```
4. Введите `bg 3`, чтобы продолжить выполнение задания **3** в фоновом режиме. Обратите внимание: поскольку оно было запущено как последнее задание, вам не нужно было добавлять число **3**.

5. Наберите `fg 1`, чтобы переместить задание **1** на передний план.

6. Нажмите `Ctrl-C`, чтобы отменить задание номер **1**, и введите задания, чтобы подтвердить, что оно больше не выполнено.

7. Используйте тот же подход для отмены заданий **2** и **3**.

8. Откройте второй терминал на своем сервере.

9. На втором терминале введите 
```bash
dd if=/dev/zero of=/dev/null &
```

10. Введите `exit`, чтобы закрыть второй терминал.

11. В другом терминале выполните команду `top`. Вы увидите, что задание **dd** все еще выполняется. 
```console
top - 15:18:58 up 2 days, 23:18,  3 users,  load average: 0,36, 0,31, 0,20
Tasks: 380 total,   2 running, 378 sleeping,   0 stopped,   0 zombie
%Cpu(s): 22,9 us, 27,4 sy,  0,0 ni, 49,3 id,  0,0 wa,  0,3 hi,  0,0 si,  0,0 st
MiB Mem :   3901,9 total,    413,3 free,   1567,8 used,   1920,7 buff/cache
MiB Swap:   4925,0 total,   4924,7 free,      0,2 used.   2033,9 avail Mem

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  54413 student   20   0  221364   1664   1664 R  99,3   0,0   0:21.14 dd
  54351 student   20   0  225044   3968   2944 R   0,7   0,1   0:01.52 top
```
>>***Screenshot:*** 
>>Cделайте скриншот экрана c результатом выполнения задания для отправки отчета.

Из команды `top` используйте `k`, чтобы убить **(kill)** задание **dd**.

> ***ПРИМЕЧАНИЕ*** В более ранних версиях оболочки Bash фоновые процессы также прекращались при завершении работы оболочки, из которой они были запущены. Чтобы предотвратить это, процесс можно запустить с помощью команды nohup перед ним. Использование nohup для этой цели больше не требуется в RHEL 8. Если родительский процесс убит, а дочерний процесс все еще активен, дочерний процесс вместо этого становится потомком systemd.

#### Управление процессами из командной строки

12. Запустите шел от пользователя **student**. В этой оболочке введите 
```bash
dd if=/dev/zero of=/dev/null &
```
Повторите эту команду три раза.

13. Введите комманду для получения списка процессов
```bash
ps aux | grep dd
```
Вывод команды показывает все строки, в которых есть буквы **dd**; вы увидите больше, чем просто процессы **dd**, но это не имеет особого значения. Только что запущенные процессы отображаются последними.

14.  Используйте **PID** одного из процессов **dd**, чтобы настроить **niceness**, используя `renice -n 5 <PID>`. Обратите внимание, что используя команду `top` вы не можете легко получить обзор процессов и их текущего приоритета.

15. Введите 
```bash
ps fax | grep -B5 dd
``` 
Параметр **-B5** показывает совпадающие строки, включая пять строк до этого. Поскольку ps fax показывает иерархические отношения между процессами, вы также должны найти оболочку и ее **PID**, из которой были запущены все процессы dd.

>>***Screenshot:*** 
>>Cделайте скриншот экрана c результатом выполнения задания для отправки отчета.

16. Найдите **PID** shell, из которой были запущены процессы **dd**, и введите 
```bash
kill -9 <PID>
```
 заменив **`<PID>`** на **PID** только что найденного shell. 
 
17. Поскольку процессы **dd** были запущены, как фоновые процессы, они не уничтожаются при уничтожении их родительской оболочки. Вместо этого они были перемещены вверх и теперь являются дочерними по отношению к процессу **systemd**.
Введите комманду ps в новом терминале и убедитесь, что процессы продолжают существовать.
```bash
ps fax | grep -B5 dd
``` 
#### Управление средней нагрузкой

18. Запустите шел от пользователя **student**. В этой оболочке введите 
```bash
dd if=/dev/zero of=/dev/null &
```
Повторите эту команду три раза.

19. Введите top и посмотрите текущую среднюю нагрузку. Через несколько секунд нажмите **q**, чтобы выйти из **top**.

20. В командной строке введите `uptime`. Вы должны увидеть числа, показывающие, что средняя нагрузка медленно увеличивается.

21. Введите `lscpu` и найдите количество процессоров. Также ищите параметр ядер на какждый ЦП, чтобы можно было рассчитать общее количество ядер ЦП.
22. Используйте `killall dd`, чтобы убить все процессы **dd**.

23. Убедитесь, что процессов с именем **dd** больше нет:
```bash
ps fax | grep -B5 dd
```
```console
    PID TTY      STAT   TIME COMMAND
      2 ?        S      0:00 [kthreadd]
--
    161 ?        S      0:00  \_ [scsi_eh_31]
    163 ?        I<     0:00  \_ [scsi_tmf_31]
    185 ?        I<     0:00  \_ [dm_bufio_cache]
    187 ?        I<     0:00  \_ [mld]
    188 ?        I<     0:01  \_ [kworker/0:1H-xfs-log/dm-4]
    189 ?        I<     0:00  \_ [ipv6_addrconf]
--
  54376 pts/0    Ss+    0:00  |       \_ -bash
  54469 ?        Ss     0:00  \_ sshd: student [priv]
  54472 ?        S      0:00      \_ sshd: student@pts/5
  54473 pts/5    Ss     0:00          \_ -bash
  54559 pts/5    R+     0:00              \_ ps fax
  54560 pts/5    S+     0:00              \_ grep --color=auto -B5 dd
```
