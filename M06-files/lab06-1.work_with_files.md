## LAB06-1. Работа с файлами

1. Убедитесь, что находитесь в домашнем каталоге. Создайте каталог **playground**. Для создания каталогов используется команда **mkdir**. 

2. Cоздайте внутри playground каталоги с именами **dir1** и **dir2**. Обратите внимание, что команда **mkdir** может принимать несколько аргументов, это позволяет создать два каталога одной командой.

3. Чтобы добавить данные в песочницу, скопируйте файл passwd из каталога /etc в текущий рабочий каталог. Для этого используется команда **cp** 
Обратите внимание на сокращение, обозначающее текущий рабочий каталог, — точку в конце команды. 

4. Повторите операцию копирования, но на этот раз с параметром **-v**, чтобы посмотреть, как она работает. 
   
5. Обратите внимание, что команда cp скопировала файл, но на этот раз вывела короткое сообщение, указывающее, что операция была выполнена. Обратите внимание, что cp перезаписала первую копию без каких-либо предупреждений. Это как раз тот случай, когда cp полагает, что вы знаете, что делаете. 

6. Выведите предупреждение, включив параметр **-i**:

Если в ответ на запрос ввести **y**, команда перезапишет существующий файл; если ввести любой другой символ (например, **n**), **cp** оставит прежнюю копию файла нетронутой.

7. Переименуйте passwd на fun.

8. Переместите переименованный файл в dir1 Для этого используется команда **mv**.

9. Переместите файл fun из каталога dir1 в каталог dir2.

10. Верните файл fun в текущий рабочий каталог.

11. Теперь посмотрим, как **mv** влияет на каталоги. Сначала переместите файл в каталог dir1:

12. Затем переместите dir1 в dir2 и проверьте их содержимое командой **ls**:

Обратите внимание: так как dir2 уже существует, mv переместит dir1 в dir2. Если бы каталога dir2 не было, mv просто переименовала бы dir1 в dir2. 

13.  Верните все на свои места, используя команду **mv**.

14.  Cоздайте несколько жестких ссылок (fun-hard) для файла fun, используя команду **ln**. Должно получиться четыре экземпляра файла fun.

```console
[student@pv playground]$ ln fun fun-hard
[student@pv playground]$ ln fun dir1/fun-hard
[student@pv playground]$ ln fun dir2/fun-hard
```

15. Проверьте, что содержит каталог playground.

>Обратите внимание на второе поле в записях, соответствующих файлам fun и fun-hard. Оба они содержат 4 — число жестких ссылок на файл, существующих в данный момент. Как вы помните, файл всегда имеет хотя бы одну жесткую ссылку, потому что имя файла определяется ссылкой. Но как убедиться, что fun и fun-hard — это один и тот же файл? В этом случае команда ls нам не помощник. Можно сказать, что fun и fun-hard имеют одинаковые размеры (поле 5), но по списку файлов нельзя уверенно утверждать, что это один и тот же файл. Чтобы решить эту задачу, заглянем поглубже.
Рассуждая о жестких ссылках, полезно представлять файлы состоящими из двух частей: раздела с данными, где хранится содержимое файла, и раздела с именем, где хранится имя файла. Создавая жесткую ссылку, мы фактически создаем дополнительный раздел с именем, ссылающийся на тот же раздел с данными. Цепочку дисковых блоков система присваивает тому, что называется индексным узлом (**inode**), который затем присваивается разделу с именем. То есть каждая жесткая ссылка ссылается на определенный индексный узел с содержимым файла.

16.  Отобразите индексный номер узла, используя команду **ls**. Для этого ее нужно вызвать с параметром **-i**:

В этой версии списка в первом поле отображается номер индексного узла, и, как можно видеть, оба имени, fun и fun-hard, ссылаются на индексные узлы с одним и тем же номером, а это подтверждает, что они соответствуют одному и тому же файлу.

17. Создайте символические ссылки, используя команду **ln** с параметром **-s**.  Примените разные способы создания символической ссылки.

```console
[student@pv playground]$ ln -s fun fun-sym
[student@pv playground]$ ln -s ../fun dir1/fun-sym
[student@pv playground]$ ln -s ../fun dir2/fun-sym
```

18. Убедитесь в том, что создавая символическую ссылку, мы фактически определяем текст, описывающий местоположение целевого файла относительно символической ссылки. Для этого используйте команду **ls** с параметром **-l**

Запись с информацией о fun-sym в dir1 сообщает, что это символическая ссылка (первый символ l в первом поле), указывающая на ../fun, что правильно. Относительно символической ссылки fun-sym файл fun находится в каталоге уровнем выше. Обратите также внимание на размер файла символической ссылки, равный 6, — это число символов в строке ../fun, а не размер файла, на который она указывает.
При создании символических ссылок можно также указывать **абсолютные пути**, например:

```console
[student@pv playground]$ ln -s /home/me/playground/fun dir1/fun-sym
```

или **относительные**, как в более раннем примере. Но предпочтительнее использовать относительные пути, потому что это позволяет переименовывать и/или перемещать каталоги, содержащие символические ссылки, не разрушая их.
Помимо обычных файлов, символические ссылки могут указывать также на каталоги:

```console
[student@pv playground]$ ln -s dir1 dir1-sym
[student@pv playground]$ ls -l
итого 16
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard
lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -> fun
```

19.  Удалите одну из жестких ссылок. Удаление файлов и каталогов выполняется при помощи команды **rm**.

В результате файл fun-hard исчез, а счетчик ссылок во втором поле в записи для файла fun уменьшился с четырех до трех. 

20. Удалите файл fun. Добавьте в команду **rm** параметр **-i**, чтобы посмотреть, что происходит:

Введите **y** в ответ на запрос, и файл будет удален.

21.  Проанализируйте вывод **ls**. Заметили, что произошло с fun-sym? Поскольку теперь символическая ссылка указывает на несуществующий файл, она стала битой:

```console
[student@pv playground]$ ls -l
итого 8
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -> fun
```

В большинстве дистрибутивов Linux команда **ls** особым образом настраивается на **отображение битых ссылок**. В Fedora битые ссылки отображаются как мигающий красный текст. Битые ссылки не представляют никакой опасности, но вносят определенную путаницу. 

22. Попробуйте использовать битую ссылку. Вы увидите:

```console
[student@pv playground]$ less fun-sym
fun-sym: Нет такого файла или каталога
```

23. Удалите символическую ссылку:

```console
[student@pv playground]$ rm fun-sym dir1-sym
[student@pv playground]$ ls -l
итого 8
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
```

## Решение

1. Убедитесь, что находитесь в домашнем каталоге. Создайте каталог **playground**. Для создания каталогов используется команда **mkdir**. 

```console
[student@pv ~]$ cd
[student@pv ~]$ mkdir playground
```

2. Cоздайте внутри playground каталоги с именами **dir1** и **dir2**. Для этого смените текущий рабочий каталог на playground и выполните еще одну команду mkdir:

```console
[student@pv ~]$ cd playground
[student@pv playground]$ mkdir dir1 dir2
```

Обратите внимание, что команда mkdir может принимать несколько аргументов, это позволяет создать два каталога одной командой.

3. Чтобы добавить данные в песочницу, командой **cp** скопируйте файл passwd из каталога /etc в текущий рабочий каталог.

```console
[student@pv playground]$ cp /etc/passwd .
```

Обратите внимание на сокращение, обозначающее текущий рабочий каталог, — точку в конце команды. Если после этого выполнить команду **ls**, мы увидим наш файл:

```console
[student@pv playground]$ ls -l
итого 12
drwxrwxr-x 2 me me 4096 2012-01-10 16:40 dir1
drwxrwxr-x 2 me me 4096 2012-01-10 16:40 dir2
-rw-r--r-- 1 me me 1650 2012-01-10 16:07 passwd
```

4. Повторите операцию копирования, но на этот раз с параметром **-v**, чтобы посмотреть, как она работает:

```console
[student@pv playground]$ cp -v /etc/passwd .
`/etc/passwd' -> `./passwd'
```

Команда cp вновь скопировала файл, но на этот раз вывела короткое сообщение, указывающее, что операция была выполнена. Обратите внимание, что cp перезаписала первую копию без каких-либо предупреждений. Это как раз тот случай, когда cp полагает, что вы знаете, что делаете. 

5. Выведите предупреждение, включив параметр **-i**:

```console
[student@pv playground]$ cp -i /etc/passwd .
cp: переписать `./passwd'?
```

Если в ответ на запрос ввести **y**, команда перезапишет существующий файл; если ввести любой другой символ (например, **n**), **cp** оставит прежнюю копию файла нетронутой.

6. Переименуйте passwd на fun:

```console
[student@pv playground]$ mv passwd fun
```

7. Переместите переименованный файл в каждый из каталогов и обратно:

```console
[student@pv playground]$ mv fun dir1
```

переместит файл в каталог dir1.

8. Следующая команда

```console
[student@pv playground]$ mv dir1/fun dir2
```

переместит файл из каталога dir1 в каталог dir2. 

9. Следующая команда

```console
[student@pv playground]$ mv dir2/fun .
```

вернет его в текущий рабочий каталог.

10. Теперь посмотрим, как **mv** влияет на каталоги. Сначала переместите файл в каталог dir1:

```console
[student@pv playground]$ mv fun dir1
```

11.  Затем переместите dir1 в dir2 и проверьте их содержимое командой **ls**:

```console
[student@pv playground]$ mv dir1 dir2
[student@pv playground]$ ls -l dir2

итого 4
drwxrwxr-x 2 student student 4096 2012-01-11 06:06 dir1
[student@pv playground]$ ls -l dir2/dir1
итого 4
-rw-r--r-- 1 student student 1650 2012-01-10 16:33 fun
```

Обратите внимание: так как dir2 уже существует, mv переместит dir1 в dir2. Если бы каталога dir2 не было, mv просто переименовала бы dir1 в dir2. 

12. Верните все на свои места:

```console
[student@pv playground]$ mv dir2/dir1 .
[student@pv playground]$ mv dir1/fun .
```

13.  Cоздайте несколько жестких ссылок для нашего файла:

```console
[student@pv playground]$ ln fun fun-hard
[student@pv playground]$ ln fun dir1/fun-hard
[student@pv playground]$ ln fun dir2/fun-hard
```

Теперь у нас есть четыре экземпляра файла fun. Посмотрим, что содержит наш каталог playground:

```console
[student@pv playground]$ ls -l
итого 16
drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir1
drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir2
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard
```

>Прежде всего следует обратить внимание на второе поле в записях, соответствующих файлам fun и fun-hard. Оба они содержат 4 — число жестких ссылок на файл, существующих в данный момент. Как вы помните, файл всегда имеет хотя бы одну жесткую ссылку, потому что имя файла определяется ссылкой. Но как убедиться, что fun и fun-hard — это один и тот же файл? В этом случае команда ls нам не помощник. Вы, конечно, скажете, что fun и fun-hard имеют одинаковые размеры (поле 5), но по списку файлов нельзя уверенно утверждать, что это один и тот же файл. Чтобы решить эту задачу, заглянем поглубже.
Рассуждая о жестких ссылках, полезно представлять файлы состоящими из двух частей: раздела с данными, где хранится содержимое файла, и раздела с именем, где хранится имя файла. Создавая жесткую ссылку, мы фактически создаем дополнительный раздел с именем, ссылающийся на тот же раздел с данными. Цепочку дисковых блоков система присваивает тому, что называется индексным узлом (**inode**), который затем присваивается разделу с именем. То есть каждая жесткая ссылка ссылается на определенный индексный узел с содержимым файла.

14. Команда **ls** может извлекать эту информацию. Для этого ее нужно вызвать с параметром **-i**:

```console
[student@pv playground]$ ls -li
итого 16
12353539 drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir1
12353540 drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir2
12353538 -rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun
12353538 -rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard
```

В этой версии списка в первом поле отображается номер индексного узла, и, как можно видеть, оба имени, fun и fun-hard, ссылаются на индексные узлы с одним и тем же номером, а это подтверждает, что они соответствуют одному и тому же файлу.

15. Создайте символические ссылки

```console
[student@pv playground]$ ln -s fun fun-sym
[student@pv playground]$ ln -s ../fun dir1/fun-sym
[student@pv playground]$ ln -s ../fun dir2/fun-sym
```

Первый пример достаточно очевиден: мы просто добавили параметр **-s**, чтобы вместо жесткой ссылки создать символическую ссылку. Но два других выглядят несколько необычно. Не забывайте, что, создавая символическую ссылку, мы фактически определяем текст, описывающий местоположение целевого файла относительно символической ссылки. В этом легко убедиться, если взглянуть на вывод команды **ls**:

```console
[student@pv playground]$ ls -l dir1
итого 4
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard
lrwxrwxrwx 1 me me 6 2012-01-15 15:17 fun-sym -> ../fun
```
Запись с информацией о fun-sym в dir1 сообщает, что это символическая ссылка (первый символ l в первом поле), указывающая на ../fun, что правильно. Относительно символической ссылки fun-sym файл fun находится в каталоге уровнем выше. Обратите также внимание на размер файла символической ссылки, равный 6, — это число символов в строке ../fun, а не размер файла, на который она указывает.
При создании символических ссылок можно также указывать абсолютные пути, например:

```console
[student@pv playground]$ ln -s /home/me/playground/fun dir1/fun-sym
```

или относительные, как в более раннем примере. Но предпочтительнее использовать относительные пути, потому что это позволяет переименовывать и/или перемещать каталоги, содержащие символические ссылки, не разрушая их.
Помимо обычных файлов, символические ссылки могут указывать также на каталоги:

```console
[student@pv playground]$ ln -s dir1 dir1-sym
[student@pv playground]$ ls -l
итого 16
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard
lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -> fun
```

16. Удалите одну из жестких ссылок. Удаление файлов и каталогов выполняется при помощи команды **rm**.

```console
[student@pv playground]$ rm fun-hard
[student@pv playground]$ ls -l
итого 12
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
-rw-r--r-- 3 me me 1650 2012-01-10 16:33 fun
lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -> fun
```

Результат получился вполне ожидаемым. Файл fun-hard исчез, и счетчик ссылок во втором поле в записи для файла fun уменьшился с четырех до трех. 

17. Удалите файл fun. Добавьте в команду параметр **-i**, чтобы посмотреть, что происходит:

```console
[student@pv playground]$ rm -i fun
rm: удалить обычный файл `fun'?
```

Введите y в ответ на запрос, и файл будет удален.

18. Проанализируйте вывод **ls**. Заметили, что произошло с fun-sym? Поскольку теперь символическая ссылка указывает на несуществующий файл, она стала битой:

```console
[student@pv playground]$ ls -l
итого 8
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -> fun
```

В большинстве дистрибутивов Linux команда **ls** особым образом настраивается на **отображение битых ссылок**. В Fedora битые ссылки отображаются как мигающий красный текст. Битые ссылки не представляют никакой опасности, но вносят определенную путаницу. 

19. Попробуйте использовать битую ссылку. Вы увидите:

```console
[student@pv playground]$ less fun-sym
fun-sym: Нет такого файла или каталога
```

20. Удалите символическую ссылку:

```console
[student@pv playground]$ rm fun-sym dir1-sym
[student@pv playground]$ ls -l
итого 8
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
```