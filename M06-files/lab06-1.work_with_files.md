##LAB06-1 Работа с файлами

##Построение песочницы
Поскольку на практике будем производить некоторые операции с файлами, необходимо создать для этого отдельный экспериментальный каталог. **Создайте** такой каталог **в своем домашнем каталоге** и назовите его **playground**.

##Создание каталогов
1. Для создания каталогов используется команда **mkdir**. Чтобы создать каталог **playground**, проверьте сначала, находитесь ли вы в домашнем каталоге, и только потом создайте новый каталог:

```console
[student@pv ~]$ cd
[student@pv ~]$ mkdir playground
```

2. Cоздайте внутри playground пару каталогов с именами **dir1** и **dir2**. Для этого смените текущий рабочий каталог на playground и выполните еще одну команду mkdir:

```console
[student@pv ~]$ cd playground
[student@pv playground]$ mkdir dir1 dir2
```

Обратите внимание, что команда mkdir может принимать несколько аргументов, это позволяет создать два каталога одной командой.

3. Добавим немного данных в песочницу. Для этого скопируем какие-нибудь файлы. Командой **cp** скопируйте файл passwd из каталога /etc в текущий рабочий каталог.

```console
[student@pv playground]$ cp /etc/passwd 
```

Обратите внимание на сокращение, обозначающее текущий рабочий каталог, — точку в конце команды. Если после этого выполнить команду **ls**, мы увидим наш файл:

```console
[student@pv playground]$ ls -l
итого 12
drwxrwxr-x 2 me me 4096 2012-01-10 16:40 dir1
drwxrwxr-x 2 me me 4096 2012-01-10 16:40 dir2
-rw-r--r-- 1 me me 1650 2012-01-10 16:07 passwd
```

4. Повторите операцию копирования, но на этот раз с параметром **-v**, чтобы посмотреть, как она работает:

```console
[student@pv playground]$ cp -v /etc/passwd .
`/etc/passwd' -> `./passwd'
```

Команда cp вновь скопировала файл, но на этот раз вывела короткое сообщение, указывающее, что операция была выполнена. Обратите внимание, что cp перезаписала первую копию без каких-либо предупреждений. Это как раз тот случай, когда cp полагает, что вы знаете, что делаете. 
5. Чтобы вывести предупреждение, включите параметр **-i**:

```console
[student@pv playground]$ cp -i /etc/passwd .
cp: переписать `./passwd'?
```

Если в ответ на запрос ввести **y**, команда перезапишет существующий файл; если ввести любой другой символ (например, **n**), **cp** оставит прежнюю копию файла нетронутой.

##Перемещение и переименование файлов

6. Имя passwd не выглядит органичным в нашей песочнице, поэтому дадим этому файлу какое-нибудь другое имя:

```console
[student@pv playground]$ mv passwd fun
```

7. Переместим переименованный файл в каждый из каталогов и обратно:

```console
[student@pv playground]$ mv fun dir1
```

переместит файл в каталог dir1.
8. Следующая команда
```console
[student@pv playground]$ mv dir1/fun dir2
```

переместит файл из каталога dir1 в каталог dir2. 
9. Следующая команда

```console
[student@pv playground]$ mv dir2/fun .
```

вернет его в текущий рабочий каталог.

10. Теперь посмотрим, как **mv** влияет на каталоги. Сначала переместите файл в каталог dir1:
```console
[student@pv playground]$ mv fun dir1
```

11. Затем переместите dir1 в dir2 и проверьте их содержимое командой **ls**:

```console
[student@pv playground]$ mv dir1 dir2
[student@pv playground]$ ls -l dir2

итого 4
drwxrwxr-x 2 me me 4096 2012-01-11 06:06 dir1
[student@pv playground]$ ls -l dir2/dir1
итого 4
-rw-r--r-- 1 me me 1650 2012-01-10 16:33 fun
```

Обратите внимание: так как dir2 уже существует, mv переместит dir1 в dir2. Если бы каталога dir2 не было, mv просто переименовала бы dir1 в dir2. 

12. В заключение верните все на свои места:

```console
[student@pv playground]$ mv dir2/dir1 .
[student@pv playground]$ mv dir1/fun .
```

##Создание жестких ссылок

13. Cоздайте несколько жестких ссылок для нашего файла:

```console
[student@pv playground]$ ln fun fun-hard
[student@pv playground]$ ln fun dir1/fun-hard
[student@pv playground]$ ln fun dir2/fun-hard
```

Теперь у нас есть четыре экземпляра файла fun. Посмотрим, что содержит наш каталог playground:

```console
[student@pv playground]$ ls -l
итого 16
drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir1
drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir2
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard
```

Прежде всего следует обратить внимание на второе поле в записях, соответствующих файлам fun и fun-hard. Оба они содержат 4 — число жестких ссылок на файл, существующих в данный момент. Как вы помните, файл всегда имеет хотя бы одну жесткую ссылку, потому что имя файла определяется ссылкой. Но как убедиться, что fun и fun-hard — это один и тот же файл? В этом случае команда ls нам не помощник. Вы, конечно, скажете, что fun и fun-hard имеют одинаковые размеры (поле 5), но по списку файлов нельзя уверенно утверждать, что это один и тот же файл. Чтобы решить эту задачу, заглянем поглубже.
Рассуждая о жестких ссылках, полезно представлять файлы состоящими из двух частей: раздела с данными, где хранится содержимое файла, и раздела с именем, где хранится имя файла. Создавая жесткую ссылку, мы фактически создаем дополнительный раздел с именем, ссылающийся на тот же раздел с данными. Цепочку дисковых блоков система присваивает тому, что называется индексным узлом (**inode**), который затем присваивается разделу с именем. То есть каждая жесткая ссылка ссылается на определенный индексный узел с содержимым файла.
14. Команда **ls** может извлекать эту информацию. Для этого ее нужно вызвать с параметром **-i**:

```console
[student@pv playground]$ ls -li
итого 16
12353539 drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir1
12353540 drwxrwxr-x 2 me me 4096 2012-01-14 16:17 dir2
12353538 -rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun
12353538 -rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard
```

В этой версии списка в первом поле отображается номер индексного узла, и, как можно видеть, оба имени, fun и fun-hard, ссылаются на индексные узлы с одним и тем же номером, а это подтверждает, что они соответствуют одному и тому же файлу.

##Создание символических ссылок

Символические ссылки были придуманы с целью преодолеть ограничения жестких ссылок: жесткие ссылки не могут указывать на файлы, находящиеся на других физических устройствах, и не могут указывать на каталоги — только на файлы. Символическая ссылка — это файл особого типа, хранящий текстовый указатель на файл или каталог.
Создаются символические ссылки почти так же, как жесткие ссылки:

```console
[student@pv playground]$ ln -s fun fun-sym
[student@pv playground]$ ln -s ../fun dir1/fun-sym
[student@pv playground]$ ln -s ../fun dir2/fun-sym
```

Первый пример достаточно очевиден: мы просто добавили параметр **-s**, чтобы вместо жесткой ссылки создать символическую ссылку. Но два других выглядят несколько необычно. Не забывайте, что, создавая символическую ссылку, мы фактически определяем текст, описывающий местоположение целевого файла относительно символической ссылки. В этом легко убедиться, если взглянуть на вывод команды **ls**:

```console
[student@pv playground]$ ls -l dir1
итого 4
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard
lrwxrwxrwx 1 me me 6 2012-01-15 15:17 fun-sym -> ../fun
```
Запись с информацией о fun-sym в dir1 сообщает, что это символическая ссылка (первый символ l в первом поле), указывающая на ../fun, что правильно. Относительно символической ссылки fun-sym файл fun находится в каталоге уровнем выше. Обратите также внимание на размер файла символической ссылки, равный 6, — это число символов в строке ../fun, а не размер файла, на который она указывает.
При создании символических ссылок можно также указывать абсолютные пути, например:

```console
[student@pv playground]$ ln -s /home/me/playground/fun dir1/fun-sym
```

или относительные, как в более раннем примере. Но предпочтительнее использовать относительные пути, потому что это позволяет переименовывать и/или перемещать каталоги, содержащие символические ссылки, не разрушая их.
Помимо обычных файлов, символические ссылки могут указывать также на каталоги:

```console
[student@pv playground]$ ln -s dir1 dir1-sym
[student@pv playground]$ ls -l
итого 16
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun
-rw-r--r-- 4 me me 1650 2012-01-10 16:33 fun-hard
lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -> fun
```

##Удаление файлов и каталогов
Как уже говорилось ранее, удаление файлов и каталогов выполняется при помощи команды **rm**. Далее мы немного почистим нашу песочницу. Сначала удалите одну из жестких ссылок:

```console
[student@pv playground]$ rm fun-hard
[student@pv playground]$ ls -l
итого 12
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
-rw-r--r-- 3 me me 1650 2012-01-10 16:33 fun
lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -> fun
```

Результат получился вполне ожидаемым. Файл fun-hard исчез, и счетчик ссылок во втором поле в записи для файла fun уменьшился с четырех до трех. Далее, удалите файл fun и ради развлечения добавьте в команду параметр **-i**, чтобы посмотреть, что происходит:

```console
[student@pv playground]$ rm -i fun
rm: удалить обычный файл `fun'?
```

Введите y в ответ на запрос, и файл будет удален. Но давайте посмотрим на вывод **ls**. Заметили, что произошло с fun-sym? Поскольку теперь символическая ссылка указывает на несуществующий файл, она стала битой:

```console
[student@pv playground]$ ls -l
итого 8
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
lrwxrwxrwx 1 me me 4 2012-01-16 14:45 dir1-sym -> dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
lrwxrwxrwx 1 me me 3 2012-01-15 15:15 fun-sym -> fun
```

В большинстве дистрибутивов Linux команда **ls** особым образом настраивается на **отображение битых ссылок**. В Fedora битые ссылки отображаются как мигающий красный текст. Битые ссылки не представляют никакой опасности, но вносят определенную путаницу. При попытке использовать битую ссылку вы увидите:

```console
[student@pv playground]$ less fun-sym
fun-sym: Нет такого файла или каталога
```

Давайте немного приберем за собой. Удалите символическую ссылку:

```console
[student@pv playground]$ rm fun-sym dir1-sym
[student@pv playground]$ ls -l
итого 8
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir1
drwxrwxr-x 2 me me 4096 2012-01-15 15:17 dir2
```

Главное, что следует помнить о символических ссылках: большинство операций с файлами воздействуют на целевой элемент, а не на саму ссылку. Однако команда rm является исключением из этого правила. Когда вы удаляете ссылку, удаляется сама ссылка, а не элемент, на который она указывает.

**В заключение удалим каталог playground. Для этого вернитесь в домашний каталог и вызовите команду rm с параметром рекурсивного удаления каталогов (-r), чтобы удалить каталог playground и все его содержимое, включая подкаталоги:**
```console
[student@pv playground]$ cd
[me@linuxbox ~]$ rm -r playground
```