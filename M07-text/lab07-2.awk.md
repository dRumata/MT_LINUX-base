Создайте favorite_food.txt файл, в котором перечислены любимые блюда группы друзей:
```bash
echo "carrot sandy
wasabi luke
sandwich brian
salad ryan
spaghetti jessica" > favorite_food.txt
```
Теперь используйте команду awk, чтобы вывести файл на экран:
```bash
awk '{print}' favorite_food.txt
```

Вы увидите файл на экране:

```console
carrot sandy
wasabi luke
sandwich brian
salad ryan
spaghetti jessica
```

Давайте попробуем возможности фильтрации поиска awk, выполнив поиск по файлу в поисках текста “sand”:
```bash
awk '/sand/' favorite_food.txt
```

```console
carrot sandy
sandwich brian
```

Чтобы отобразить только строку, начинающуюся с букв “sand”, используйте регулярное выражение ^sand:
```bash
awk '/^sand/' favorite_food.txt
```

На этот раз отображается только одна строка:

```console
sandwich brian
```

Аналогичным образом, вы можете использовать раздел действия, чтобы указать, какие фрагменты информации вы хотите распечатать. Например, чтобы напечатать только первый столбец, используйте следующую команду:
```bash
awk '/^sand/ {print $1;}' favorite_food.txt
```

```console
sandwich
```

>***Примечание: Внутренними переменными, которые использует awk, являются:***
**FILENAME**: Ссылается на текущий входной файл.
**FNR**: Ссылается на номер текущей записи относительно текущего входного файла. Например, если у вас есть два входных файла, это сообщит вам номер записи каждого файла, а не общее количество.
**FS**:  Текущий разделитель полей, используемый для обозначения каждого поля в записи. По умолчанию для этого параметра задано значение пробела.
**NF**: Количество полей в текущей записи.
**NR**: Номер текущей записи.
**OFS**: Разделитель полей для выводимых данных. По умолчанию для этого параметра задано значение пробела.
**ORS**: Разделитель записей для выводимых данных. По умолчанию это символ новой строки.
**RS**: Разделитель записей, используемый для разделения отдельных записей во входном файле. По умолчанию это символ новой строки.

Ключевые слова BEGIN и END - это определенные наборы условий, точно так же, как и параметры поиска. Они совпадают до и после обработки документа.

Это означает, что вы можете изменить некоторые внутренние переменные в разделе BEGIN. Например, файл /etc/passwd разделен двоеточиями `:` вместо пробелов.
Чтобы распечатать первый столбец этого файла, выполните следующую команду:
```
awk 'BEGIN { FS=":"; }
{ print $1; }' /etc/passwd
```

```console
root
daemon
bin
sys
sync
games
man
. . .
```

Вы можете использовать блоки BEGIN и END для печати информации о печатаемых полях. Используйте следующую команду, чтобы преобразовать данные из файла в таблицу, разделенную табуляциями с помощью `\t`:
```bash
awk 'BEGIN { FS=":"; print "User\t\tUID\t\tGID\t\tHome\t\tShell\n--------------"; }
{print $1,"\t\t",$3,"\t\t",$4,"\t\t",$6,"\t\t",$7;}
END { print "---------\nFile Complete" }' /etc/passwd
```

Вы увидите этот вывод:

```console
User		UID		GID		Home		Shell
--------------
root 		 0 		 0 		 /root 		 /bin/bash
daemon 		 1 		 1 		 /usr/sbin 		 /bin/sh
bin 		 2 		 2 		 /bin 		 /bin/sh
sys 		 3 		 3 		 /dev 		 /bin/sh
sync 		 4 		 65534 		 /bin 		 /bin/sync
. . .
---------
File Complete
```

Создайте новую версию favorite_food.txt файл, который добавляет номер товара перед едой каждого человека:
```bash
echo "1 carrot sandy
2 wasabi luke
3 sandwich brian
4 salad ryan
5 spaghetti jessica" > favorite_food.txt
```

Если вы хотите найти все продукты из этого файла, начинающиеся на “sa”, вы можете начать с того, что попробуете что-то вроде этого:
```bash
awk '/sa/' favorite_food.txt
```

Здесь показаны все строки, содержащие “sa”:

```console
1 carrot sandy
2 wasabi luke
3 sandwich brian
4 salad ryan
```

Вы можете указать awk, чтобы он соответствовал только началу второго столбца, используя эту команду:
```bash
awk '$2 ~ /^sa/' favorite_food.txt
```

```console
3 sandwich brian
4 salad ryan
```

Вы можете так же легко искать вещи, которые не совпадают, включив символ `!` перед тильдой `~`. Эта команда вернет все строки, в которых нет food, начинающегося на “sa”:
```bash
awk '$2 !~ /^sa/' favorite_food.txt
```

```console
1 carrot sandy
2 wasabi luke
5 spaghetti jessica
```

Если позже вы решите, что вас интересуют только строки, которые не начинаются с “sa”, а номер элемента меньше 5, вы могли бы использовать составное выражение, подобное этому:
```bash
awk '$2 !~ /^sa/ && $1 < 5' favorite_food.txt
```

Вы увидите этот вывод:

```console
1 carrot sandy
2 wasabi luke
```

Вы можете использовать команду awk для анализа выходных данных других программ вместо указания имени файла. Например, вы можете использовать awk для анализа IPv4-адреса из команды ip.
Чтобы отобразить информацию для интерфейса с именем eth0, используйте эту команду:
```bash
ip a s eth0
```

Вы увидите следующие результаты:

```console
2571: eth0@if2572: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:0b brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.11/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
```

Вы можете использовать awk для настройки таргетинга на строку inet, а затем распечатать только IP-адрес:
```bash
ip a s eth0 | awk -F '[\/ ]+' '/inet / {print $3}'
```

На выходе отображается IP-адрес:

```console
172.17.0.11
```

Флаг -F указывает awk разделять с помощью косой черты или пробелов, используя регулярное выражение `[\/ ]+`. Это разбивает строку inet 172.17.0.11/16 на отдельные поля. IP-адрес находится в третьем поле, потому что пробелы в начале строки также считаются полем, поскольку вы разделяете их пробелами, а также косыми чертами. Обратите внимание, что в этом случае awk обрабатывал последовательные пробелы как один пробел.
